class Solution {
    public int[] solution(int n, int s) {
        int[] answer = null;
        if(n > s) {                                     // 갯수가 합보다 클 수 없다. 
            return new int[]{-1};                           // 3개로 2를 만들 수 없다.
        }
        answer = new int[n];                            // 자연수 n개로 이루어진 집합 초기화
        for(int i=0; i<n;i++){                          // 1차원 배열의 모든 원소를 n / s로 초기화    
            answer[i] = s / n;
        }
        int remainder = s % n;
        for(int i = n-1; i >= n - remainder; i--) {     // 배열의 값에 1씩 더한다.
            answer[i]++;
        }
        return answer;
    }
}
// *가장 큰 수로 이루어진 집합 구하기.
    // 1. 크기가 n인 배열의 모든 원소를 몫으로 세팅
    // 2. 나머지가 0보다 클 때, 나머지만큼 1씩 더한다.
// 합이 s가 되는 경우의수 
    // [1, (s-1)], [2, (s-2)], ... [(s-1), 1]
    // 절반은 동일한 경우의 수 
// 2(2) - 1 + 1
    // 경우의 수가 한 가지
// 3(2) - 1 + 2
    // 경우의 수가 한 가지
// 3(3) - 1 + 1 + 1
    // 경우의 수가 한 가지
// 4(2) - 1 + 3, 2 + 2
    // 특정 수만 큰 경우보다 골고루 큰 수들이 모였을 때 곱이 더 큼.
    // 즉, 각 원소들간의 차가 적은 수들이 모였을 때 곱이 더 큼.
    // 3 < 4
// 4(3) - 1 + 1 + 2
    // 경우의 수가 한 가지
// 4(4) - 1 + 1 + 1 + 1
    // 경우의 수가 한 가지
// 5(3) - 1 + 1 + 3, 1 + 2 + 2 
    // 원소들간의 차가 적은 수들이 모였을 때 곱이 더 큼.
    // 3 < 4
// 6(3) - 1 + 1 + 4, 1 + 2 + 3, 2 + 2 +2
    // 4 < 6 < 8
// 9(2) - 1 + 8, 2 + 7, 3 + 6, 4 + 5
    // 원소들간의 차가 적은 수들이 모였을 때 곱이 더 큼.
    // 8 < 14 < 18 < 20
// *오름차순의 집합을 반환해야 한다.
    // 1씩 더해줄 때, 뒤에서 부터 더해준다.